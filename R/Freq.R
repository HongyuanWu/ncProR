#' Computation of the K-Mer Frequencies of RNA or Protein Sequences
#' @description This function can calculate the \emph{k}-mer frequencies of RNA or protein sequences.
#' Three kinds of protein representations are available.
#'
#' @param seqs sequences loaded by function \code{\link[seqinr]{read.fasta}} of package
#' "seqinr" (\code{\link[seqinr]{seqinr-package}}). Or a list of RNA/protein sequences.
#' RNA sequences will be converted into lower case letters, but
#' protein sequences will be converted into upper case letters.
#' Each sequence should be a vector of single characters.
#' @param seqType a string that specifies the nature of the sequence: \code{"RNA"} or \code{"Pro"} (protein).
#' If the input is DNA sequence and \code{seqType = "RNA"}, the DNA sequence will be converted to RNA sequence automatically.
#' Default: \code{"RNA"}.
#' @param computePro a string that specifies the computation mode of protein sequence: \code{"RPISeq"}, \code{"DeNovo"},
#' or \code{"rpiCOOL"}. Ignored when \code{seqType = "RNA"}.
#' Three modes indicate three different amino acid residues classifications that corresponds to the methods "RPISeq", "De Novo prediction",
#' and "rpiCOOL". See details below. Default: \code{"RPISeq"}.
#' @param k an integer that indicates the sliding window step. Default: \code{3}.
#' @param normalize can be \code{"none"}, \code{"row"} or \code{"column"}. If the frequencies should be normalized.
#' If normalize, should the features be normalized by row (each sequence) or by column (each feature)?
#' See details below. Default: \code{"none"}.
#' @param normData is the normalization data generated by this function.
#' Only used to extract features of test set and \code{normalize = "column"}.
#' If the input dataset is training set, or normalize strategy is \code{"none"} or \code{"row"},
#' just leave \code{normData = NULL}. The normalization data will be computed
#' based on the input dataset.
#' @param parallel.cores an integer specfying the number of cores for parallel computation. Default: \code{2}.
#' Set \code{parallel.cores = -1} to run with all the cores.
#'
#' @return This function returns a data frame. Row names are the sequences names, and column names are the polymer names.
#' If minimum and maximum values are computed, the function will return a list containing features (data frame) and normalization
#' values for the feature extraction of testing set.
#' @details Function \code{computeFreq} calculate the \emph{k}-mer frequencies of RNA/protein sequences. Three computation modes
#' of protein frequencies are:
#'
#' \code{RPISeq}:
#' \{A, G, V\}, \{I, L, F, P\}, \{Y, M, T, S\}, \{H, N, Q, W\}, \{R, K\}, \{D, E\}, \{C\}
#' (Ref: [3]);
#'
#' \code{DeNovo}:
#' \{D, E\}, \{H, R, K\}, \{C, G, N, Q, S, T, Y\}, \{A, F, I, L, M, P, V, W\}
#' (Ref: [4]).
#'
#' \code{rpiCOOL}:
#' \{A, E\}, \{I, L, F, M, V\}, \{N, D, T, S\}, \{G\}, \{P\}, \{R, K, Q, H\}, \{Y, W\}, \{C\}
#' (Ref: [5]).
#'
#' The function provides two normalization strategies: by row (each sequence) or by column (each feature).
#' If by row, the dataset will be processed with equation (Ref: [2]):
#' di = (fi - min\{f1, f2, ...\}) / max\{f1, f2, ...\}.
#' f1, f2, ..., fi are the original values of each row.
#'
#' If by column, the dataset will be processed with:
#' di = (fi - min\{f1, f2, ...\}) / (max\{f1, f2, ...\} - min\{f1, f2, ...\}).
#'
#' In [2], normalization is computed by row (each sequence).
#'
#' @section References:
#' [1] Han S, Liang Y, Li Y, \emph{et al}.
#' ncProR: an integrated R package for effective ncRNA-protein interaction prediction.
#' (\emph{Submitted})
#'
#' [2] Shen J, Zhang J, Luo X, \emph{et al}.
#' Predicting protein-protein interactions based only on sequences information.
#' Proc. Natl. Acad. Sci. U. S. A. 2007; 104:4337-41
#'
#' [3] Muppirala UK, Honavar VG, Dobbs D.
#' Predicting RNA-protein interactions using only sequence information.
#' BMC Bioinformatics 2011; 12:489
#'
#' [4] Wang Y, Chen X, Liu Z-P, \emph{et al}.
#' De novo prediction of RNA-protein interactions from sequence information.
#' Mol. BioSyst. 2013; 9:133-142
#'
#' [5] Akbaripour-Elahabad M, Zahiri J, Rafeh R, \emph{et al}.
#' rpiCOOL: A tool for In Silico RNA-protein interaction detection using random forest.
#' J. Theor. Biol. 2016; 402:1-8
#'
#' @importFrom parallel makeCluster
#' @importFrom parallel clusterExport
#' @importFrom parallel parSapply
#' @importFrom parallel stopCluster
#' @importFrom parallel detectCores
#' @importFrom seqinr count
#' @seealso \code{\link{featureFreq}}
#' @examples
#'
#' ### Use "read.fasta" function of package "seqinr" to read a FASTA file:
#' seqs1 <- seqinr::read.fasta(file =
#' "http://www.ncbi.nlm.nih.gov/WebSub/html/help/sample_files/nucleotide-sample.txt")
#' seqFreq1 <- computeFreq(seqs1, seqType = "RNA", k = 4, normalize = "none",
#'                         parallel.cores = 2)
#'
#' data(demoPositiveSeq)
#' seqs2 <- demoPositiveSeq$Pro.positive
#'
#' seqFreq2 <- computeFreq(seqs2, seqType = "Pro", computePro = "RPISeq", k = 3,
#'                         normalize = "column", parallel.cores = 2)
#'
#' seqFreq3 <- computeFreq(seqs2, seqType = "Pro", computePro = "RPISeq", k = 3,
#'                         normalize = "column", normData = seqFreq2$normData,
#'                         parallel.cores = 2)
#'
#' @export

computeFreq <- function(seqs, seqType = c("RNA", "Pro"), computePro = c("RPISeq", "DeNovo", "rpiCOOL"),
                        k = 3, normalize = c("none", "row", "column"), normData = NULL,
                        parallel.cores = 2) {

        normalize <- match.arg(normalize)
        # browser()

        flagComputeNorm <- FALSE
        if (normalize == "column" & is.null(normData)) flagComputeNorm <- TRUE

        message("+ Initializing...  ", Sys.time())
        seqType <- match.arg(seqType)
        computePro <- match.arg(computePro)

        if (parallel.cores == 2) message("- Users can try to set parallel.cores = -1 to use all cores!")
        parallel.cores <- ifelse(parallel.cores == -1, parallel::detectCores(), parallel.cores)
        cl <- parallel::makeCluster(parallel.cores)
        parallel::clusterExport(cl, "Internal.checkRNA", envir = environment())

        if (seqType == "RNA") {
                message("\n", "+ Calculating RNA sequences...", Sys.time(), "\n", "- The value of k is ", k, " (Normalize: ", normalize, ").")
        } else {
                message("\n", "+ Calculating protein sequences...", Sys.time(), "\n",  "- The value of k is ", k, " (Normalize: ", normalize, ", Mode: ", computePro, ").")
        }

        features <- parallel::parSapply(cl, seqs, Internal.computeFreq, seqType = seqType,
                                        computePro = computePro, k = k)
        parallel::stopCluster(cl)
        features <- t(features)


        if (normalize == "none") {
                out_features <- as.data.frame(features)
        } else if (normalize == "column") {
                if (flagComputeNorm) {
                        normMin <- apply(features, 2, min)
                        normMax <- apply(features, 2, max)
                } else {
                        normMin <- normData$normMin
                        normMax <- normData$normMax
                }

                freq.out <- apply(features, 1, function(x) {
                        out <- (x - normMin) / (normMax - normMin)
                })
                features <- as.data.frame(t(freq.out))
                features <- Internal.checkNa(features)
                out_features <- list(feature = features,
                                     normData = list(seqType = seqType,
                                                     normMin = normMin, normMax = normMax))
        } else {
                normMin <- apply(features, 1, min)
                normMax <- apply(features, 1, max)

                freq.out <- apply(features, 2, function(x) {
                        out <- (x - normMin) / normMax
                })
                out_features <- as.data.frame(freq.out)
                features <- Internal.checkNa(features)
                }

        message("\n", "+ Completed.  ", Sys.time(), "\n")
        out_features
}

#' Extraction of the \emph{K}-Mer Features of RNA and Protein Sequences
#' @description Basically a wrapper for \code{\link{computeFreq}} function.
#' This function can calculate the \emph{k}-mer frequencies of RNA and protein sequences at the same time
#' and format the results as the dataset that can be used to build classifier.
#'
#' @param seqRNA RNA sequences loaded by function \code{\link[seqinr]{read.fasta}} of package
#' "seqinr" (\code{\link[seqinr]{seqinr-package}}). Or a list of RNA sequences.
#' RNA sequences will be converted into lower case letters.
#' Each sequence should be a vector of single characters.
#' @param seqPro protein sequences loaded by function \code{\link[seqinr]{read.fasta}} of package
#' "seqinr" (\code{\link[seqinr]{seqinr-package}}). Or a list of protein sequences.
#' Protein sequences will be converted into upper case letters.
#' Each sequence should be a vector of single characters.
#' @param label optional. A string that indicates the class of the samples such as
#' "Interact", "Non.Interact". Default: \code{NULL}
#' @param featureMode a string that can be \code{"concatenate"} or \code{"combine"}.
#' If \code{"concatenate"}, the \emph{k}-mer features of RNA and proteins will be simply concatenated.
#' If \code{"combine"}, the returned dataset will be formed by combining the \emph{k}-mer features of RNA and proteins.
#' See details below. Default: \code{"concatenate"}.
#' @param computePro a string that specifies the computation mode of protein sequence: \code{"RPISeq"}, \code{"DeNovo"},
#' or \code{"rpiCOOL"}. Ignored when \code{seqType = "RNA"}.
#' Three modes indicate three different amino acid residues classifications that corresponds to the methods "RPISeq", "De Novo prediction",
#' and "rpiCOOL". See details below. Default: \code{"RPISeq"}.
#' @param k.Pro an integer that indicates the sliding window step of RNA sequences. Default: \code{4}.
#' @param k.RNA an integer that indicates the sliding window step of protein sequences. Default: \code{3}.
#' @param normalize can be \code{"none"}, \code{"row"} or \code{"column"}. Whether the frequencies should be normalized.
#' If normalize, the features should be normalized based on each row (sequence) or each column (feature)?
#' See details below. Default: \code{"none"}.
#' @param normData is the normalization data generated by this function.
#' Only used to extract features of test set and \code{normalize = "column"}.
#' If the input dataset is training set, or normalize strategy is \code{"none"} or \code{"row"},
#' just leave \code{normData = NULL}. The normalization data will be computed
#' based on the input dataset.
#' @param parallel.cores an integer specfying the number of cores for parallel computation. Default: \code{2}.
#' Set \code{parallel.cores = -1} to run with all the cores.
#'
#' @return This function returns a data frame. Row names are the sequences names, and column names are the polymer names.
#' The names of RNA and protein sequences are seperated with ".",
#' i.e. the row names format: "\emph{RNASequenceName}.\emph{proteinSequenceName}" (e.g. "YDL227C.YOR198C").
#' If \code{featureMode = "combine"}, the polymers of RNA and protein sequences are also seperated with ".",
#' i.e. the column format: "\emph{RNAPolymerName}.\emph{proteinPolymerName}" (e.g. aa.CCA).
#' @details
#' see \code{\link{computeFreq}}.
#'
#' @section References:
#' [1] Han S, Liang Y, Li Y, \emph{et al}.
#' ncProR: an integrated R package for effective ncRNA-protein interaction prediction.
#' (\emph{Submitted})
#'
#' [2] Shen J, Zhang J, Luo X, \emph{et al}.
#' Predicting protein-protein interactions based only on sequences information.
#' Proc. Natl. Acad. Sci. U. S. A. 2007; 104:4337-41
#'
#' [3] Muppirala UK, Honavar VG, Dobbs D.
#' Predicting RNA-protein interactions using only sequence information.
#' BMC Bioinformatics 2011; 12:489
#'
#' [4] Wang Y, Chen X, Liu Z-P, \emph{et al}.
#' De novo prediction of RNA-protein interactions from sequence information.
#' Mol. BioSyst. 2013; 9:133-142
#'
#' [5] Akbaripour-Elahabad M, Zahiri J, Rafeh R, \emph{et al}.
#' rpiCOOL: A tool for In Silico RNA-protein interaction detection using random forest.
#' J. Theor. Biol. 2016; 402:1-8
#'
#' @importFrom parallel makeCluster
#' @importFrom parallel clusterExport
#' @importFrom parallel parSapply
#' @importFrom parallel stopCluster
#' @importFrom parallel detectCores
#' @importFrom seqinr count
#' @seealso \code{\link{computeFreq}}
#' @examples
#' data(demoPositiveSeq)
#' seqsRNA <- demoPositiveSeq$RNA.positive
#' seqsPro <- demoPositiveSeq$Pro.positive
#'
#' dataset1 <- featureFreq(seqRNA = seqsRNA, seqPro = seqsPro, label = "Interact",
#'                         featureMode = "comb", computePro = "DeNovo", k.Pro = 3,
#'                         k.RNA = 2, normalize = "row", parallel.cores = 2)
#'
#' dataset2 <- featureFreq(seqRNA = seqsRNA, seqPro = seqsPro, featureMode = "conc",
#'                         computePro = "rpiCOOL", k.Pro = 3, k.RNA = 4,
#'                         normalize = "column", parallel.cores = 2)
#'
#' dataset3 <- featureFreq(seqRNA = seqsRNA, seqPro = seqsPro, featureMode = "conc",
#'                         computePro = "rpiCOOL", k.Pro = 3, k.RNA = 4,
#'                         normalize = "column", normData = dataset2$normData,
#'                         parallel.cores = 2)
#'
#' @export

featureFreq <- function(seqRNA, seqPro, label = NULL, featureMode = c("concatenate", "combine"),
                        computePro = c("RPISeq", "DeNovo", "rpiCOOL"), k.Pro = 3, k.RNA = 4,
                        normalize = c("none", "row", "column"), normData = NULL,
                        parallel.cores = 2) {

        if (length(seqRNA) != length(seqPro)) stop("The number of RNA sequences should match the number of protein sequences!")

        featureMode <- match.arg(featureMode)

        if (normalize == "column" & !is.null(normData)) {
                featureRNA <- computeFreq(seqs = seqRNA, seqType = "RNA", k = k.RNA,
                                          normalize = normalize, normData = normData$normData_RNA,
                                          parallel.cores = parallel.cores)
                featurePro <- computeFreq(seqs = seqPro, seqType = "Pro", k = k.Pro,
                                          normalize = normalize, computePro = computePro,
                                          normData = normData$normData_Pro,
                                          parallel.cores = parallel.cores)
        } else {
                featureRNA <- computeFreq(seqs = seqRNA, seqType = "RNA", k = k.RNA,
                                          normalize = normalize, normData = NULL,
                                          parallel.cores = parallel.cores)
                featurePro <- computeFreq(seqs = seqPro, seqType = "Pro", k = k.Pro,
                                          normalize = normalize, computePro = computePro,
                                          normData = NULL, parallel.cores = parallel.cores)
        }


        if (normalize == "column") {
                normData <- list(normData_RNA = featureRNA$normData, normData_Pro = featurePro$normData)
                featureRNA <- featureRNA$feature
                featurePro <- featurePro$feature
        }

        sequenceName <- paste(row.names(featureRNA), row.names(featurePro), sep = ".")

        if (featureMode == "combine") {
                featureName <- sapply(names(featureRNA), function(nameRNA) {
                        names <- paste(nameRNA, names(featurePro), sep = ".")
                })
                featureName <- as.character(featureName)
                featureValue <- mapply(Internal.combineMotifs, oneRNA = as.data.frame(t(featureRNA)),
                                       onePro = as.data.frame(t(featurePro)))
                features <- as.data.frame(t(featureValue), row.names = sequenceName)
                names(features) <- featureName
        } else {
                features <- cbind(featureRNA, featurePro, row.names = sequenceName)
        }

        if (!is.null(label)) features <- data.frame(label = label, features)

        if (normalize == "column") {
                features <- list(feature = features, normData = normData)
        }
        features
}
